/
 <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <head>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
    <link rel="stylesheet" href="../css/style.css"></style>
    <script src="../js/dynam.space.js"></script> 
<style>
div {
 background-color: white;
 color: black;
}
body{
 background-color: white;
}

</style>
  </head>

  <body>
  <div id="main">
  <div id="buttons">
    <button v-show="!info.hasStarted" @click="start">Start</button>
    <button v-show="info.isRunning" @click="stop">Stop</button>
    <button v-show="info.hasStarted && !info.isRunning" @click="reset">Reset</button>
  </div>
  <div id='experiments'>
	  <button v-for="(param, idx) in params" :class="{ active: isActive(param) }" @click="load(param)">
       {{idx}}
    </button>
  </div>
  <div>
  </div>
  <div>
    <canvas id="myCanvas" ref="myCanvas" width="600" height="600"></canvas>
  </div>
  <div>
   <br>
   Machine play stack:
          <input type='checkbox' v-model="P.playstacky">
          <br>
   Random initialization:
          <input type='checkbox' v-model="P.userandominit">
          <br>
   Noise: 
          <input type='checkbox' v-model="P.usenoise">
          <br>
  <template v-if="P.mode!='both'">
  <template v-if="P.mode!='mouse'">
   Other play stack:
          <input type='checkbox' v-model="P.playstackx">
          <br>
  </template>
  </template>
          <br>
   Show gradient:
          <input type='checkbox' v-model="P.showcostgradient">
          <br>
   Show curvature:
          <input type='checkbox' v-model="P.showcostcurvature">
          <br>
   Show stack gradient:
          <input type='checkbox' v-model="P.showcoststackgradient">
          <br>
   Show stack curvature:
          <input type='checkbox' v-model="P.showcoststackcurvature">
          <br>
   Show average difference:
          <input type='checkbox' v-model="P.showcostdiff">
          <br>
   Plot learning dynamics:
          <input type='checkbox' v-model="P.history">
          <br>
          <br>
   Show more info:
          <input type='checkbox' v-model="P.showinfo">
          <br>
          <br>
  {{ P.mode=='mouse'?"Minimize your" : "Horizontal player's" }} cost: 
  <br>
  {{O.costx.toFixed(1)}}
  <br>
  <br>
  Vertical  player's cost: 
  <br>
  {{O.costy.toFixed(1)}}
  <br>
  <br>
  <template v-if="P.mode!='both'">
  <template v-if="P.mode!='mouse'">
  Learning rate (x):
  <br>
  <input v-model.number="P.alpha">
  <br>
  <br>
  </template>
  Learning rate (machine):
  <br>
  <input v-model.number="P.beta">
  </template>

  <template v-if="P.showinfo">
   <br>
   <br>
   More info:
   <br>
   (x,y) = ({{ (S.x/P.scale).toFixed(2) }},{{ (S.y/P.scale).toFixed(2) }})
   <br>
   <br>
   costs
   <input type="checkbox" v-model="P.showcostx">
   <input type="checkbox" v-model="P.showcosty">
   <br>
   <br>
   nash 
   <input type='checkbox' v-model="P.showg">: 
   <br>
   ({{P.xnash}},{{P.ynash}}) <br>
   <br>
   stack (p1 leader) 
   <input type='checkbox' v-model="P.showgstack1">: 
   <br>
   ({{P.xstack1}},{{P.ystack1}}) <br>
   <br>
   stack (p2 leader) 
   <input type='checkbox' v-model="P.showgstack2">: 
   <br>
   ({{P.xstack2}}, {{P.ystack2}}) <br>
   <br>
   conj  (p1 and p2 leaders)
   <input type='checkbox' v-model="P.showgconj">: 
   <br>
   ({{P.xconj}}, {{P.yconj}})<br>
   <br>
          conj2 (p1 conj, p2 stack)
          <input type='checkbox' v-model="P.showgstacktwo">:
          <br>
          ({{P.xstacktwo.toFixed(1)}},{{P.ystacktwo.toFixed(1)}})
   <br>


          <br>
   a: <input v-model.number="P.a">
          <br>
   d: <input v-model.number="P.d">
          <br>
   noise (x): <input v-model.number="P.noisestdx">
          <br>
   noise (y): <input v-model.number="P.noisestdy">
          <br>
          <br>
  </template>
  </div>
  <div></div>
  <div>
   <template v-if="P.showinfo">
   <br>
   <br>
   Continous game:
   <br>
   <br>
   minimize f1(x,y), minimize f2(x,y)
   <br>
   &nbsp;&nbsp;
   x
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   y

  <br>
  <br>
  <br>
   Costs:
   <br>
   f1(x,y) = ax<sup>2</sup>/2 + bxy + hy<sup>2</sup>/2
   <br>
   f2(x,y) = ex<sup>2</sup>/2 + cxy + dy<sup>2</sup>/2
   <br>
   <br>
   Gradients:
   <br>
   <span :style="Math.abs(O.gradstackx) >= Math.abs(O.gradx)? 'color:green' : ''">
   g1(x,y) = ax + by = {{(O.gradx/P.scale).toFixed(2)}}
   </span>
   <br>
   <span :style="Math.abs(O.gradstackx) < Math.abs(O.gradx)? 'color:green' : ''">
   gstack1(x,y) = {{(O.gradstackx/P.scale).toFixed(2)}}
   </span>
   <br>
   <span :style="Math.abs(O.gradstacky) >= Math.abs(O.grady)? 'color:green' : ''">
   g2(x,y) = cx + dy = {{(O.grady/P.scale).toFixed(2)}}
   </span>
   <br>
   <span :style="Math.abs(O.gradstacky) < Math.abs(O.grady)? 'color:green' : ''">
   gstack2(x,y) = {{(O.gradstacky/P.scale).toFixed(2)}}
   </span>
   <br>
   <br>
   Learning Dynamics:
   <br>
   x &lArr;  x -  αg1(x,y)
   <br>
   y &lArr;  y -  βg2(x,y)
   <br>
   <br>
   Game Jacobian:
   <br>
   J(x,y) = ⎡a  b⎤ = ⎡{{P.a.toFixed(1)}}  {{P.b.toFixed(1)}}⎤ 
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ⎣c  d⎦ = ⎣{{P.c.toFixed(1)}} {{P.d.toFixed(1)}}⎦
   <br>
   
   <br>
   <br>
   For more info, see papers: 
   <br>
   arXiv:<a href="https://arxiv.org/abs/2011.03650">2011.03650</a> 
   and 
   arXiv:<a href="https://arxiv.org/abs/2011.05562">2011.05562</a> 
   
   </template>
  </div>

  </div>

<script>
const s = (v) => Math.sin(v)
const c = (v) => Math.cos(v)

const experiments = {
  'play': {
    mode: 'mouse',
    edit: false
   },
  'sim': {
    mode: 'simgrad',
   },
  'manual': {
    mode: 'both',
    edit: false
   },
  'edit': {
    edit: true,
   },
  'show all': {
    showinfo: true,
    showcostx: true,
    showcosty: true,
    showinfo: true,
    showg: true,
    showgstack1: true,
    showgstack2: true,
    showgconj: true,
   }
}


const data = {
  P: { //parameters
    mode: 'mouse',
    edit: false,
    inputmode: 'absolute',//or absolute
    colorx: '#00287D',
    colory: '#FD5A5D',
    colornash: '#227739',
    colorstack1: '#185DA3',
    colorstack2: '#92299F',
    colorstacktwo: '#80AB00',
    colorconj: '#8F5400',
    duration: 100, //seconds
    period: 20, //ms
    smooth: 0.95,
    playstackx: false,
    playstacky: false,
    alpha: 0.001,
    beta: 0.001,
    xnash: -1,
    ynash: -1,
    xstack1: 1,
    ystack1: 1,
    xstack2: .1,
    ystack2: .8,
    xconj: 1.3,
    yconj: .3,
    x1: 0,
    x2: 0,
    y1: 0,
    y2: -2,
    a: 1.8,
    b: -.15,
    c: .15,
    d: .7,
    e: 3,
    h: 1,
    scale: 40,
    scalecost: 50,
    lvlset: 1,
    history: false,
    showinfo: false,
    showcostx: true,
    showcosty: false,
    showg: false,
    showgstack1: false,
    showgstack2: false,
    showgconj: false,
    showgstacktwo: false,
    showcostdiff: false,
    showcostgradient: false,
    showcostcurvature: false,
    userandominit: false,
    usenoise: false,
    noisestdx: 10,
    noisestdy: 10,
    pointradius: 10,
    nash1: null,
    nash2: null,
  },
  I: { //inputs
    posX: 0,
    posY: 0,
  },
  O: { //outputs
    time: 0,
    costx: 0,
    costy: 0,
    gradx: 0,
    grady: 0,
    gradstackx: 0,
    gradstacky: 0
  },
  S: { //state
    time: 0,
    x: 0,
    y: 0,
    xcostsmoothed: 0,
  },
}

 function recompute(P) {
  P.xnash = P.draggables[0].x/P.scale
  P.ynash = P.draggables[0].y/P.scale
  P.xstack1 = P.draggables[1].x/P.scale
  P.ystack1 = P.draggables[1].y/P.scale
  P.xstack2 = P.draggables[2].x/P.scale
  P.ystack2 = P.draggables[2].y/P.scale
  P.xconj = P.draggables[3].x/P.scale
  P.yconj = P.draggables[3].y/P.scale

  const xn = P.xnash
  const yn = P.ynash
  const xs1 = P.xstack1
  const ys1 = P.ystack1
  const xs2 = P.xstack2
  const ys2 = P.ystack2

  const xr = xs1
  const yr = ys1
  const xs = xs2
  const ys = ys2
  const xc = P.xconj
  const yc = P.yconj
  const a = P.a
  const c = P.d
  const h = P.h
  const e = P.e

  P.x1 = (xn*xs1*yc - xs1*xs2*yc - xc*xs2*yn + xs1*xs2*yn - xc*xn*ys1 + xc*xs2*ys1 + xc*xn*ys2 - xn*xs1*ys2)/
    (xn*yc - xs2*yc - xc*yn + xs1*yn - xn*ys1 + xs2*ys1 + xc*ys2 - xs1*ys2)
  P.x2 = (xn*xs2*yc - xs1*xs2*yc - xc*xs1*yn + xs1*xs2*yn + xc*xn*ys1 - xn*xs2*ys1 - xc*xn*ys2 + xc*xs1*ys2)/
    (xn*yc - xs1*yc - xc*yn + xs2*yn + xc*ys1 - xs2*ys1 - xn*ys2 + xs1*ys2) 
  P.y1 = (xs1*yc*yn - xs2*yc*yn - xc*yn*ys1 + xs2*yn*ys1 + xn*yc*ys2 - xs1*yc*ys2 + xc*ys1*ys2 - xn*ys1*ys2)/
    (xn*yc - xs2*yc - xc*yn + xs1*yn - xn*ys1 + xs2*ys1 + xc*ys2 - xs1*ys2)
  P.y2 = (-xs1*yc*yn + xs2*yc*yn + xn*yc*ys1 - xs2*yc*ys1 - xc*yn*ys2 + xs1*yn*ys2 + xc*ys1*ys2 - xn*ys1*ys2)/
    (xn*yc - xs1*yc - xc*yn + xs2*yn + xc*ys1 - xs2*ys1 - xn*ys2 + xs1*ys2)
  P.b = (-a*xn + a*xs2)/(yn - ys2)
  P.c = (-c*yn + c*ys1)/(xn - xs1) 
  P.e = (c*(xs1*yc*yn - xs2*yc*yn + xc*yn*yn - xs2*yn*yn - xn*yc*ys1 + xs2*yc*ys1 - xc*yn*ys1 + xs2*yn*ys1 + xn*yc*ys2 - xs1*yc*ys2 - 
     xc*yn*ys2 - xs1*yn*ys2 + 2*xs2*yn*ys2 + xc*ys1*ys2 + xn*ys1*ys2 - 2*xs2*ys1*ys2 - xn*ys2*ys2 + xs1*ys2*ys2))/((xn - 
     xs1)*(xc - xs2)*(xn - xs2))
  P.h = (a*(xn*xn*yc - xn*xs1*yc - xn*xs2*yc + xs1*xs2*yc + xc*xs1*yn -
     xs1*xs1*yn - xc*xs2*yn + xs1*xs2*yn - xc*xn*ys1 - xn*xn*ys1 +
     2*xn*xs1*ys1 + xc*xs2*ys1 + xn*xs2*ys1 - 2*xs1*xs2*ys1 +
     xc*xn*ys2 - xc*xs1*ys2 - xn*xs1*ys2 + xs1*xs1*ys2))/((yc -
     ys1)*(yn - ys1)*(yn - ys2))


   P.xstacktwo = (xn**2*xs*(yc - yr)*(yc - ys)**2 + xc*xr**2*(yc - ys)**2*(-yn + ys) - 
      xs*(yn - yr)*(xs**2*(yc - yn)*(yc - yr) + 
      2*xc*xs*(yc - yr)*(yn - ys) + 
           xc**2*(yn*yr + yc*(-yn + yr) - 2*yr*ys + ys**2)) - 
      xn*(yc - ys)*(xs**2*(yc - yr)*(yc - 2*yn + yr) + 
      2*xc*xs*(yc - yr)*(yn - ys) + 
           xc**2*(yr - ys)**2 + 
      xr*(yc - ys)*(xs*(yc - yr) + xc*(-yr + ys))) + 
      xr*(yc - ys)*(xs**2*(yc - yn)*(yc - yr) + 
      xc**2*(yn - ys)*(yr - ys) - 
      xc*xs*(2*yn*yr + yn*ys - 3*yr*ys + yc*(-3*yn + yr + 2*ys))))/ ((xn)**2*(yc - yr)*(yc - ys)**2 + xr*(xs*(yc + yn - 2*yr) + xc*(yn - ys))*(yc - ys)**2 + 
        xr**2*(yc - ys)**2*(-yn + ys) 
        + (yn - yr)*(
          (-(xs)*(xs))*(yc - yr)*
          (2*yc - yn - ys) + 
           xc**2*(yc - yr)*(yn - ys) + 
      xc*xs*(yc**2 + 2*yn*yr - 2*yc*(yn + yr - ys) - ys**2)) - 
      xn*(yc - ys)*(xs*(yc - yr)*(yc - 2*yn + 2*yr - ys) + 
      xr*(yc - ys)*(yc - 2*yr + ys) - 
      xc*(2*yn*yr - 2*yr**2 + yr*ys - ys**2 + yc*(-2*yn + yr + ys))))

   P.ystacktwo = ((-xc)*xn*yc**2*yr**2 + xn**2*yc**3*ys - 2*xc*xn*yc**2*yn*ys +
   xc**2*yc*yn**2*ys +
      3*xc*xn*yc**2*yr*ys - xn**2*yc**2*yr*ys - xc**2*yc*yn*yr*ys +
   2*xc*xn*yc*yn*yr*ys -
      xc**2*yn**2*yr*ys + xc**2*yn*yr**2*ys - 2*xn**2*yc**2*ys**2 -
   xc**2*yc*yn*ys**2 +
      2*xc*xn*yc*yn*ys**2 + xc**2*yc*yr*ys**2 - 4*xc*xn*yc*yr*ys**2 +
   2*xn**2*yc*yr*ys**2 +
      xc**2*yn*yr*ys**2 - 2*xc*xn*yn*yr*ys**2 - xc**2*yr**2*ys**2 +
   xc*xn*yr**2*ys**2 +
      xn**2*yc*ys**3 + xc*xn*yr*ys**3 - xn**2*yr*ys**3 +
   xr**2*yc*(yc - ys)**2*(-yn + ys) +
      xs**2*(yc - yr)*(-yn + yr)*(yc**2 - yn*ys) -
   xn*xs*(yc - yr)*(yc - ys)*
        (yc*yr + (-2*yn + yr)*ys) -
   xc*xs*(yn - yr)*(yc**2*(yr - 2*ys) + 2*yc*yn*ys +
           yr*ys*(-2*yn + ys)) +
   xr*(yc - ys)**2*(xs*(2*yc*yn - yc*yr - yn*yr) +
           xc*yr*(yn - ys) + xn*(yc*yr - 2*yc*ys + yr*ys)))/
   (xn**2*(yc - yr)*(yc - ys)**2 +
   xr*(xs*(yc + yn - 2*yr) + xc*(yn - ys))*(yc - ys)**2 +
      xr**2*(yc - ys)**2*(-yn + ys) + (yn -
      yr)*((-xs*xs)*(yc - yr)*(2*yc - yn - ys) +
           xc**2*(yc - yr)*(yn - ys) +
      xc*xs*(yc**2 + 2*yn*yr - 2*yc*(yn + yr - ys) - ys**2)) -
      xn*(yc - ys)*(xs*(yc - yr)*(yc - 2*yn + 2*yr - ys) +
      xr*(yc - ys)*(yc - 2*yr + ys) -

      xc*(2*yn*yr - 2*yr**2 + yr*ys - ys**2 + yc*(-2*yn + yr + ys))))



  }

function reset(S, I, O, P) {
  if(P.userandominit) {
  S.x = (Math.random()-0.5)*400
  S.y = (Math.random()-0.5)*400 
   }
  else {
    S.x = 0
    S.y = -150
   }
  S.xcostsmoothed = null
  P.draggables = 
   [{x: P.xnash*P.scale, y:P.ynash*P.scale, isDragging: false},
    {x: P.xstack1*P.scale, y:P.ystack1*P.scale, isDragging: false},
    {x: P.xstack2*P.scale, y:P.ystack2*P.scale, isDragging: false},
    {x: P.xconj*P.scale, y:P.yconj*P.scale, isDragging: false}]
  
  recompute(P)
 }

function update(S, I, O, P) {
  var xx1 = (S.x-P.x1*P.scale)
  var yy1 = (S.y-P.y1*P.scale)
  var xx2 = (S.x-P.x2*P.scale)
  var yy2 = (S.y-P.y2*P.scale)

  O.costx = P.a*xx1*xx1/2 + P.b*xx1*yy1 + P.h*yy1*yy1/2
  O.costy = P.d*yy2*yy2/2 + P.c*xx2*yy2 + P.e*xx2*xx2/2
  O.costx /= P.scale**2
  O.costy /= P.scale**2
  
  if(S.xcostsmoothed === null) {
    S.xcostsmoothed = O.costx
   }
  else
  {
    S.xcostsmoothed = P.smooth*S.xcostsmoothed + (1-P.smooth)*O.costx
   }

  O.gradx = P.a*xx1 + P.b*yy1
  O.grady = P.c*xx2 + P.d*yy2
  
  O.gradstackx = O.gradx - (P.c*(P.b*xx1+P.h*yy1))/P.d
  O.gradstacky = O.grady - (P.b*(P.c*yy2+P.e*xx2))/P.a
  if (P.usenoise) {
    O.gradx += 2*(Math.random()-0.5)*P.noisestdx**2
    O.grady += 2*(Math.random()-0.5)*P.noisestdy**2
    O.gradstackx += 2*(Math.random()-0.5)*P.noisestdx**2
    O.gradstacky += 2*(Math.random()-0.5)*P.noisestdy**2
   }
  const grady = P.playstacky ? O.gradstacky : O.grady
  const gradx = P.playstackx ? O.gradstackx : O.gradx
  switch (P.mode) {
    case 'simgrad':
     S.x = S.x - P.alpha*gradx
     S.y = S.y - P.beta*grady
     break;
    case 'mouse': 
     S.x = I.posX
     S.y = S.y - P.beta*grady
     break;
    case 'both':
     S.x = I.posX
     S.y = I.posY
     break;
   }
}

function draw(canvas, S, I, O, P, H) {
  let ctx = canvas.getContext('2d')
  let w = canvas.width
  let h = canvas.height

  recompute(P)

  ctx.strokeStyle = 'white'
  ctx.fillStyle = 'black'
  ctx.lineWidth = 3

  ctx.font = '36px Unknown Font, sans-serif'
  ctx.save();
  ctx.lineWidth = 20
  ctx.strokeStyle = 'black'
  ctx.setTransform(1,0,0,1,0,0)
  ctx.fillText(O.costx.toFixed(2), 20, 40)
  if (P.showcostdiff) {
  ctx.beginPath();
  ctx.moveTo(0, 30);
  dcost = S.xcostsmoothed-O.costx
  if (dcost<0) ctx.strokeStyle = '#882143'
  if (dcost>0) ctx.strokeStyle = '#007e00'
  ctx.lineTo(0, 30+dcost*P.scalecost);
  ctx.stroke();
   }
  ctx.restore();

  //ctx.strokeRect(-w/2, -h/2, w, h)

  if(P.showinfo && P.showcostx){
  ctx.strokeStyle = P.colorx
  r1 = (P.a+P.h)/2 + Math.sqrt((P.a - P.h)**2/4+P.b*P.b)
  r2 = (P.a+P.h)/2 - Math.sqrt((P.a - P.h)**2/4+P.b*P.b)
  t = Math.atan2(r1-P.a, P.b)
  for (var i=0; i<5; i++) {
  ctx.beginPath();
  ctx.ellipse(P.x1*P.scale, P.y1*P.scale, Math.sqrt(r2)*i*P.scale*P.lvlset, Math.sqrt(r1)*i*P.scale*P.lvlset, t, 0, 2*Math.PI)
  ctx.stroke()
   }
  ctx.beginPath();
  ctx.arc(P.x1*P.scale, P.y1*P.scale, 1, 0, 2*Math.PI)
  ctx.fill()

   }

  if(P.showinfo && P.showcosty){
  ctx.strokeStyle = P.colory
  r1 = (P.d+P.e)/2 + Math.sqrt((P.e - P.d)**2/4+P.c*P.c)
  r2 = (P.d+P.e)/2 - Math.sqrt((P.e - P.d)**2/4+P.c*P.c)
  t = Math.atan2(r1-P.e, P.c)
  for (var i=0; i<5; i++) {
  ctx.beginPath();
  ctx.ellipse(P.x2*P.scale, P.y2*P.scale, Math.sqrt(r2)*i*P.scale*P.lvlset, Math.sqrt(r1)*i*P.scale*P.lvlset, t, 0, 2*Math.PI)

  ctx.stroke()
   }
  ctx.beginPath();
  ctx.arc(P.x2*P.scale, P.y2*P.scale, 1, 0, 2*Math.PI)
  ctx.fill()
   }

  ctx.lineWidth = 20;
  if (P.mode == 'both') {
    x = I.posX
    y = I.posY
   } else if (P.mode == 'mouse') {
     x = I.posX
     y = S.y
   } else if (P.mode == 'simgrad') {
     x = S.x
     y = S.y
    }


    xx1 = (x-P.x1*P.scale)
    yy1 = (y-P.y1*P.scale)
    gradx = P.a*xx1 + P.b*yy1
    gradstackx = gradx - P.c*(P.b*xx1+P.h*yy1)/P.d

    const shifty = h/2-50
    const mc = 200
    const mg = 30
    const scalecost = 1/100
    const scalegrad = 1/100
  ctx.lineWidth = 6

  if (P.showcostcurvature) {
  ctx.beginPath();
    ctx.strokeStyle = "#3855A7"
  ctx.moveTo(x-mc, (-mc*gradx + P.a*(-mc)**2 )*scalegrad+shifty)
  for(var dx = -mc; dx < mc; dx+=0.1) {
    ctx.lineTo(x+dx, (dx*gradx + P.a*dx**2)*scalegrad+shifty)
   }
  ctx.stroke()
   }
  if (P.showcostgradient) {
    ctx.beginPath();
    ctx.strokeStyle = "#6C8CF1"
    ctx.moveTo(x-mg, -mg*gradx*scalegrad+shifty)
    for(var dx = -mg; dx < mg; dx+=1) {
      ctx.lineTo(x+dx, dx*gradx*scalegrad+shifty)
     }
    ctx.stroke()
   } 
  if (P.showcoststackcurvature) {
  ctx.beginPath();
    ctx.strokeStyle = "#0DAAAD"
  ctx.moveTo(x-mc, (-mc*gradstackx + (P.a-P.b*P.c)/P.d*(-mc)**2 )*scalegrad+shifty)
  for(var dx = -mc; dx < mc; dx+=0.1) {
    ctx.lineTo(x+dx, (dx*gradstackx + P.a*dx**2)*scalegrad+shifty)
   }
  ctx.stroke()
   }
  if (P.showcoststackgradient) {
    ctx.beginPath();
    ctx.strokeStyle = "#40CDD2"
    ctx.moveTo(x-mg, -mg*gradstackx*scalegrad+shifty)
    for(var dx = -mg; dx < mg; dx+=1) {
      ctx.lineTo(x+dx, dx*gradstackx*scalegrad+shifty)
     }
    ctx.stroke()
   } 
  if(P.showcostgradient || P.showcostcurvature) {
  ctx.beginPath();
  ctx.strokeStyle = P.colorx
   ctx.moveTo(x-3, shifty)
   ctx.lineTo(x+3, shifty)
  ctx.stroke()


   }else {
  ctx.lineWidth = 20
  ctx.strokeStyle = P.colorx
  ctx.beginPath();
   ctx.moveTo(x-5, h/2)
   ctx.lineTo(x+5, h/2)
  ctx.stroke()
   }

  if (P.mode != 'mouse' || P.showinfo) {
  ctx.strokeStyle = P.colory
   ctx.beginPath();
   ctx.moveTo(w/2, y-5) 
   ctx.lineTo(w/2, y+5)
   ctx.stroke()
   }


  ctx.lineWidth = 2
  if (P.history && H.S.x.length >= 1) {
  ctx.strokeStyle = "black"
   ctx.beginPath();
   ctx.moveTo(H.S.x[0], H.S.y[0]) 
    for (var i =0; i< H.S.x.length; i+= 2) {
ctx.lineTo(H.S.x[i], H.S.y[i])
     }
   ctx.stroke()
   }

  
  if(P.showinfo){


  if(P.showgstacktwo){
  ctx.fillStyle = P.colorstacktwo
  ctx.beginPath();
  ctx.arc(P.xstacktwo*P.scale, P.ystacktwo*P.scale, P.pointradius, 0, 2*Math.PI)
  ctx.fill()
  ctx.strokeStyle = P.colorstacktwo
  // gstack1
  ctx.beginPath();
  const dx = (P.x1-P.xstacktwo)*100
  const dy = (P.y1-P.ystacktwo)*100
  ctx.moveTo(P.x1*P.scale-dx*P.scale,P.y1*P.scale-dy*P.scale)
  ctx.lineTo(P.x1*P.scale+dx*P.scale,P.y1*P.scale+dy*P.scale)
  ctx.stroke();
   }

  if(P.showg) {
  ctx.fillStyle = P.colornash
  ctx.strokeStyle = P.colornash
    if(P.showcostx){
  // g1
  ctx.beginPath();
  y=-500;ctx.moveTo(P.b*(P.y1*P.scale-y)/P.a+P.x1*P.scale,y)
  y=500; ctx.lineTo(P.b*(P.y1*P.scale-y)/P.a+P.x1*P.scale,y)
  ctx.stroke();
     }

    if(P.showcosty) {
  // g2
  ctx.beginPath();
  x=-500;ctx.moveTo(x,P.c*(P.x2*P.scale-x)/P.d+P.y2*P.scale)
  x=500; ctx.lineTo(x,P.c*(P.x2*P.scale-x)/P.d+P.y2*P.scale)
  ctx.stroke();
   }
    if(P.showcostx && P.showcosty){
  ctx.beginPath();
  ctx.arc(P.xnash*P.scale, P.ynash*P.scale, P.pointradius, 0, 2*Math.PI)
  ctx.fill()
   }
   }

    if(P.showgstack1){
  ctx.fillStyle = P.colorstack1
  ctx.strokeStyle = P.colorstack1
  ctx.beginPath();
  ctx.arc(P.xstack1*P.scale, P.ystack1*P.scale, P.pointradius, 0, 2*Math.PI)
  ctx.fill()
  // gstack1
  ctx.beginPath();
  y=-500;ctx.moveTo((P.c*P.h-P.b*P.d)*(P.y1*P.scale-y)/(P.b*P.c-P.a*P.d)+P.x1*P.scale,y)
  y=500; ctx.lineTo((P.c*P.h-P.b*P.d)*(P.y1*P.scale-y)/(P.b*P.c-P.a*P.d)+P.x1*P.scale,y)
  ctx.stroke();
     }

    if(P.showgstack2){
  ctx.fillStyle = P.colorstack2
  ctx.strokeStyle = P.colorstack2
  // gstack2
      if(P.machinestack) ctx.lineWidth=4
  ctx.beginPath();
  x=-500;ctx.moveTo(x,(P.a*P.c-P.b*P.e)*(P.x2*P.scale-x)/(P.a*P.d-P.b*P.c)+P.y2*P.scale);
  x=500; ctx.lineTo(x,(P.a*P.c-P.b*P.e)*(P.x2*P.scale-x)/(P.a*P.d-P.b*P.c)+P.y2*P.scale);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(P.xstack2*P.scale, P.ystack2*P.scale, P.pointradius, 0, 2*Math.PI)
  ctx.fill()
      ctx.lineWidth=2
     }



    if(P.showgconj){
  ctx.fillStyle = P.colorconj
  ctx.beginPath();
  ctx.arc(P.xconj*P.scale, P.yconj*P.scale, P.pointradius, 0, 2*Math.PI)
  ctx.fill()
     }

  ctx.fillStyle = 'black'
  ctx.beginPath();
  ctx.arc(S.x, S.y, 8, 0, 2*Math.PI)
  ctx.fill()

    




   } // end show info

  

 }

function inputs(canvas, S, I, O, P, x, y) {

  if (P.inputmode == 'lock') {
    I.movX = I.movX + x 
    I.movY = I.movY - y
  //}
  //if (P.inputmode == 'absolute') {
  //  I.posX = x - canvas.width/2
  //  I.posY = canvas.height -y
  //}
    I.posX = I.movX
    I.posY = I.movY
   } else {
    I.posX = x - canvas.width/2
    I.posY = canvas.height/2 -y
    }

  if (P.mode == 'lqr') I.posX = x

}

DynamSpace(update, draw, inputs, reset, data, experiments)

	</script>
</body>
</html>
