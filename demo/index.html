<html>
 <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <head>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
    <link rel="stylesheet" href="../css/style.css"></style>
    <script src="../js/dynam.space.js"></script> 
  </head>

  <body>
  <div id="main">
  <div id="buttons">
    <button v-show="!info.hasStarted" @click="start">Start</button>
    <button v-show="info.isRunning" @click="stop">Stop</button>
    <button v-show="info.hasStarted && !info.isRunning" @click="reset">Reset</button>
  </div>
  <div id='experiments'>
	  <button v-for="(param, idx) in params" :class="{ active: isActive(param) }" @click="load(param)">
       {{idx}}
    </button>
  </div>
  <div>
  </div>
  <div>
    <canvas id="myCanvas" ref="myCanvas" width="300" height="300"></canvas>
  </div>
  <div>
   <br>
   Plot learning dynamics:
          <input type='checkbox' v-model="P.history">
          <br>
   Machine play stack:
          <input type='checkbox' v-model="P.playstack">
          <br>
   Show more info:
          <input type='checkbox' v-model="P.showinfo">
          <br>
          <br>
  {{ P.mode=='mouse'?"Your" : "Horizontal player's" }} cost: 
  <br>
  {{O.costx.toFixed(1)}}
  <br>
  <br>
  Vertical   player's cost: 
  <br>
  {{O.costy.toFixed(1)}}
  <br>
  <br>
  <template v-if="P.mode!='both'">
  <template v-if="P.mode!='mouse'">
  Horizontal's learning rate:
  <br>
  <input v-model.number="P.alpha">
  <br>
  <br>
  </template>
  Vertical's learning rate:
  <br>
  <input v-model.number="P.beta">
  </template>

  <template v-if="P.showinfo">
   <br>
   <br>
   nash: 
   <br>
   <input v-model.number="P.xnash">
   <input v-model.number="P.ynash">
          <br>
   stack: 
   <br>
   <input v-model.number="P.xstack">
    <input v-model.number="P.ystack">
          <br>
   conj: 
          <br>
   <input v-model.number="P.xconj">
    <input v-model.number="P.yconj">
          <br>
          <br>
   a: <input v-model.number="P.a">
          <br>
   b: <input v-model.number="P.b">
          <br>
   d: <input v-model.number="P.d">
          <br>
   e: <input v-model.number="P.dd">
          <br>
          <br>
  </template>
  </div>
  <div></div>
  <div>
   <template v-if="P.showinfo">
   <br>
   <br>
   Continous game:
   <br>
   <br>
   minimize f1(x,y), minimize f2(x,y)
   <br>
   &nbsp;&nbsp;
   x
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   y

  <br>
  <br>
  <br>
   Costs:
   <br>
   f1(x,y) = ax<sup>2</sup>/2 + bxy + hy<sup>2</sup>/2
   <br>
   f2(x,y) = ex<sup>2</sup>/2 + cxy + dy<sup>2</sup>/2
   <br>
   <br>
   Gradients:
   <br>
   g1(x,y) = ax + by = {{(O.gradx/P.scale).toFixed(2)}}
   <br>
   g2(x,y) = cx + dy = {{(O.grady/P.scale).toFixed(2)}}
   <br>
   gstack1(x,y) = {{(O.gradstackx/P.scale).toFixed(2)}}
   <br>
   gstack1(x,y) = {{(O.gradstacky/P.scale).toFixed(2)}}
   <br>
   <br>
   Learning Dynamics:
   <br>
   x &lArr;  x -  αg1(x,y)
   <br>
   y &lArr;  y -  βg2(x,y)
   <br>
   <br>
   Game Jacobian:
   <br>
   J(x,y) = ⎡a  b⎤
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ⎣c  d⎦
   <br>
   
   <br>
   <br>
   For more info, see papers: 
   <br>
   arXiv:<a href="https://arxiv.org/abs/2011.03650">2011.03650</a> 
   and 
   arXiv:<a href="https://arxiv.org/abs/2011.05562">2011.05562</a> 
   
   </template>
  </div>

  </div>

<script>
const s = (v) => Math.sin(v)
const c = (v) => Math.cos(v)

const experiments = {
  'play': {
    mode: 'mouse'
   },
  'sim': {
    mode: 'simgrad'
   },
  'manual': {
    mode: 'both'
   }
}


const data = {
  P: { //parameters
    mode: 'mouse',
    inputmode: 'absolute',//or absolute
    colorx: 'red',
    colory: '#899FEC',
    duration: 100, //seconds
    period: 20, //ms
    smooth: 0.9,
    playstack: false,
    alpha: 0.03,
    beta: 0.03,
    xnash: -1,
    ynash: -1,
    xstack: 1,
    ystack: 1,
    xconj: 1.3,
    yconj: .3,
    x1: 0,
    x2: 0,
    y1: 0,
    y2: -2,
    a: 1.8,
    aa: 1,
    b: -.15,
    c: .15,
    d: .7,
    dd: 3,
    h: 1,
    z11: 3,
    z12: 3,
    z21: -3,
    z22: -2,
    scale: 20,
    lvlset: 1,
    history: false,
    showinfo: true,
    nash1: null,
    nash2: null,
  },
  I: { //inputs
    posX: 0,
    posY: 0,
  },
  O: { //outputs
    time: 0,
    costx: 0,
    costy: 0,
    gradx: 0,
    grady: 0,
    gradstackx: 0,
    gradstacky: 0
  },
  S: { //state
    time: 0,
    x: 0,
    y: 0,
  },
}

 function recompute(P) {

  const xnash = P.xnash
  const ynash = P.ynash
  const xstack = P.xstack
  const ystack = P.ystack
  const xconj = P.xconj
  const yconj = P.yconj
  const y2 = P.y2
  const a = P.a
  const c = P.d
  const b1 = P.b
  const h = P.aa
  const e = P.dd

  // NASH STACK
  P.x1 = -((a*(b1*(xnash - xstack)*(xnash - xstack) + h*xnash*(ynash - ystack)) + 
     b1*(b1*(xnash - 2*xstack) + h*(ynash - ystack))*(ynash - 
        ystack))/((b1*b1 - a*h)*(ynash - ystack)));
  P.x2 =(xnash*y2 - xstack*y2 + xstack*ynash - xnash*ystack)/(ynash - ystack);
  P.y1 = (a*a*(xnash - xstack)*(xnash - xstack) + b1*b1*ynash*(ynash - ystack) - 
   a*(ynash - ystack)*(-2*b1*xnash + 2*b1*xstack + h*ystack))/((b1*b1 -
      a*h)*(ynash - ystack));
  P.c = (c*(-ynash + ystack))/(xnash - xstack)

  // NASH STACK CONJ
  P.x1 = (a*xnash*(xconj - xstack) + b1*xstack*(yconj - ynash) + b1*xconj*(ynash - ystack))/(a*(xconj - xstack) + b1*(yconj - ystack))
  P.x2 = (-a*c*(xnash - xstack)*(xstack*(-yconj + ynash) + xnash*(yconj - ystack) + xconj*(-ynash + ystack)) + b1*(e*xconj*(xnash - xstack)*(xnash-xstack) + c*(ynash - ystack)*(xstack*(yconj - ynash) + xnash*(-yconj + ystack))))/(b1*(e*(xnash - xstack)*(xnash-xstack) - c*(ynash - ystack)*(ynash-ystack)))
  P.y1 = (b1*ynash*(yconj - ystack) + a*(-xstack*yconj + xnash*(yconj - ystack) + xconj*ystack))/(a*(xconj - xstack) + b1*(yconj - ystack));

  P.y2 = (-a*c*(ynash - ystack)*(xstack*(-yconj + ynash) + xnash*(yconj - ystack) + xconj*(-ynash + ystack)) + b1*(-c*yconj*(ynash - ystack)*(ynash-ystack) + e*(xnash - xstack)*(-xstack*ynash + xconj*(ynash - ystack) + xnash*ystack)))/(b1*(e*(xnash - xstack)*(xnash - xstack) - c*(ynash - ystack)*(ynash-ystack)))

  P.c = (c*(-ynash + ystack))/(xnash - xstack)
  P.aa = (a*(xconj - xstack)*(xnash - xstack) - b1*(xstack*(yconj + ynash - 2*ystack) + xnash*(-yconj + ystack) + xconj*(-ynash + ystack)))/((yconj - ystack)*(-ynash + ystack))


  P.z11 = P.x1
  P.z12 = P.y1
  P.z21 = P.x2
  P.z22 = P.y2
  }

function reset(S, I, O, P) {
  S.x = -100
  S.y = 100
  recompute(P)
 }

function update(S, I, O, P) {
  var x1 = (S.x-P.z11*P.scale)
  var y1 = (S.y-P.z12*P.scale)
  var x2 = (S.x-P.z21*P.scale)
  var y2 = (S.y-P.z22*P.scale)

  O.costx = P.a*x1*x1/2 + P.b*x1*y1 + P.aa*y1*y1/2
  O.costy = P.d*y2*y2/2 + P.c*x2*y2 + P.dd*x2*x2/2
  O.costx /= P.scale**2
  O.costy /= P.scale**2

  O.gradx = P.a*x1 + P.b*y1
  O.grady = P.c*x2 + P.d*y2
  O.gradstackx = O.gradx - (P.c*(P.b*x1+P.aa*y1))/P.d
  O.gradstacky = O.grady - (P.b*(P.c*y2+P.dd*x2))/P.a
  const gradm = P.playstack ? O.gradstacky : O.grady
  switch (P.mode) {
    case 'simgrad':
     S.x = S.x - P.alpha*O.gradx
     S.y = S.y - P.beta*gradm
     break;
    case 'mouse': 
     S.x = I.posX
     S.y = S.y - P.beta*gradm
     break;
    case 'both':
     S.x = I.posX
     S.y = I.posY
     break;
   }
}

function draw(canvas, S, I, O, P, H) {
  let ctx = canvas.getContext('2d')
  let w = canvas.width
  let h = canvas.height

  recompute(P)

  ctx.strokeStyle = 'white'
  ctx.fillStyle = 'white'
  ctx.lineWidth = 3

  ctx.strokeRect(-w/2, -h/2, w, h)



  ctx.strokeStyle = P.colorx
  r1 = (P.a+P.aa)/2 + Math.sqrt((P.a - P.aa)**2/4+P.b*P.b)
  r2 = (P.a+P.aa)/2 - Math.sqrt((P.a - P.aa)**2/4+P.b*P.b)
  t = Math.atan2(r1-P.a, P.b)
  for (var i=0; i<5; i++) {
  ctx.beginPath();
  ctx.ellipse(P.z11*P.scale, P.z12*P.scale, Math.sqrt(r2)*i*P.scale*P.lvlset, Math.sqrt(r1)*i*P.scale*P.lvlset, t, 0, 2*Math.PI)
  ctx.stroke()
   }
  ctx.beginPath();
  ctx.arc(P.z11*P.scale, P.z12*P.scale, 1, 0, 2*Math.PI)
  ctx.fill()


  ctx.strokeStyle = P.colory
  r1 = (P.d+P.dd)/2 + Math.sqrt((P.dd - P.d)**2/4+P.c*P.c)
  r2 = (P.d+P.dd)/2 - Math.sqrt((P.dd - P.d)**2/4+P.c*P.c)
  t = Math.atan2(r1-P.dd, P.c)
  for (var i=0; i<5; i++) {
  ctx.beginPath();
  ctx.ellipse(P.z21*P.scale, P.z22*P.scale, Math.sqrt(r2)*i*P.scale*P.lvlset, Math.sqrt(r1)*i*P.scale*P.lvlset, t, 0, 2*Math.PI)

  ctx.stroke()
   }
  ctx.beginPath();
  ctx.arc(P.z21*P.scale, P.z22*P.scale, 1, 0, 2*Math.PI)
  ctx.fill()

  ctx.lineWidth = 20;
  if (P.mode == 'both') {
    x = I.posX
    y = I.posY
   } else if (P.mode == 'mouse') {
     x = I.posX
     y = S.y
   } else if (P.mode == 'simgrad') {
     x = S.x
     y = S.y
    }

  ctx.lineWidth = 20
  ctx.strokeStyle = P.colorx
  ctx.beginPath();
   ctx.moveTo(x-5, -h/2)
   ctx.lineTo(x+5, -h/2)
  ctx.stroke()

  ctx.strokeStyle = P.colory
   ctx.beginPath();
   ctx.moveTo(w/2, y-5) 
   ctx.lineTo(w/2, y+5)
   ctx.stroke()

  ctx.beginPath();
  ctx.arc(S.x, S.y, 8, 0, 2*Math.PI)
  ctx.fill()

  ctx.lineWidth = 2
  if (P.history && H.S.x.length >= 1) {
  ctx.strokeStyle = "white"
   ctx.beginPath();
   ctx.moveTo(H.S.x[0], H.S.y[0]) 
    for (var i =0; i< H.S.x.length; i+= 2) {
ctx.lineTo(H.S.x[i], H.S.y[i])
     }
   ctx.stroke()
   }

  
  if(P.showinfo){
  ctx.fillStyle = 'navajowhite'
  ctx.beginPath();
  ctx.arc(P.xnash*P.scale, P.ynash*P.scale, 5, 0, 2*Math.PI)
  ctx.fill()

  ctx.fillStyle = 'salmon'
  ctx.beginPath();
  ctx.arc(P.xstack*P.scale, P.ystack*P.scale, 3, 0, 2*Math.PI)
  ctx.fill()

  ctx.fillStyle = 'green'
  ctx.beginPath();
  ctx.arc(P.xconj*P.scale, P.yconj*P.scale, 3, 0, 2*Math.PI)
  ctx.fill()
   }
 }

function inputs(canvas, S, I, O, P, x, y) {

  if (P.inputmode == 'lock') {
    I.movX = I.movX + x 
    I.movY = I.movY - y
  //}
  //if (P.inputmode == 'absolute') {
  //  I.posX = x - canvas.width/2
  //  I.posY = canvas.height -y
  //}
    I.posX = I.movX
    I.posY = I.movY
   } else {
    I.posX = x - canvas.width/2
    I.posY = canvas.height/2 -y
    }

  if (P.mode == 'lqr') I.posX = x

}

DynamSpace(update, draw, inputs, reset, data, experiments)

	</script>
</body>
</html>
