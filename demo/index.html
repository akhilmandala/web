
<html>
 <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <head>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
    <link rel="stylesheet" href="../css/style.css"></style>
    <script src="../js/dynam.space.js"></script> 
  </head>

  <body>
  <div id="main">
  <div id="buttons">
    <button v-show="!info.hasStarted" @click="start">Start</button>
    <button v-show="info.isRunning" @click="stop">Stop</button>
    <button v-show="info.hasStarted && !info.isRunning" @click="reset">Reset</button>
  </div>
  <div id='experiments'>
	  <button v-for="(param, idx) in params" :class="{ active: isActive(param) }" @click="load(param)">
       {{idx}}
    </button>
  </div>
  <div>
  </div>
  <div>
    <canvas id="myCanvas" ref="myCanvas" width="300" height="300"></canvas>
  </div>
  <div>
   <br>
   Plot learning dynamics:
          <input type='checkbox' v-model="P.history">
          <br>
   Show more info:
          <input type='checkbox' v-model="P.showinfo">
          <br>
          <br>
  {{ P.mode=='mouse'?"Your" : "Horizontal player's" }} cost: 
  <br>
  {{O.costx.toFixed(1)}}
  <br>
  <br>
  Vertical   player's cost: 
  <br>
  {{O.costy.toFixed(1)}}
  <br>
  <br>
  <template v-if="P.mode!='both'">
  <template v-if="P.mode!='mouse'">
  Horizontal's learning rate:
  <br>
  <input v-model.number="P.alpha">
  <br>
  <br>
  </template>
  Vertical's learning rate:
  <br>
  <input v-model.number="P.beta">
  </template>
  </div>
  <div></div>
  <div>
   <template v-if="P.showinfo">
   <br>
   <br>
   Continous game:
   <br>
   <br>
   minimize f1(x,y), minimize f2(x,y)
   <br>
   &nbsp;&nbsp;
   x
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   &nbsp;
   y

  <br>
  <br>
  <br>
   Costs:
   <br>
   f1(x,y) = ax<sup>2</sup>/2 + bxy + ry<sup>2</sup>/2
   <br>
   f2(x,y) = sx<sup>2</sup>/2 + cxy + dy<sup>2</sup>/2
   <br>
   <br>
   Gradients:
   <br>
   g1(x,y) = ax + by 
   <br>
   g2(x,y) = cx + dy
   <br>
   <br>
   Learning Dynamics:
   <br>
   x &lArr;  x -  αg1(x,y)
   <br>
   y &lArr;  y -  βg2(x,y)
   <br>
   <br>
   Game Jacobian:
   <br>
   J(x,y) = ⎡a  b⎤
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ⎣c  d⎦
   <br>
   
   <br>
   <br>
   For more info, see papers: 
   <br>
   arXiv:<a href="https://arxiv.org/abs/2011.03650">2011.03650</a> 
   and 
   arXiv:<a href="https://arxiv.org/abs/2011.05562">2011.05562</a> 
   
   </template>
  </div>

  </div>

<script>
const s = (v) => Math.sin(v)
const c = (v) => Math.cos(v)

const experiments = {
  'play': {
    mode: 'mouse'
   },
  'sim': {
    mode: 'simgrad'
   },
  'manual': {
    mode: 'both'
   }
}


const data = {
  P: { //parameters
    mode: 'mouse',
    inputmode: 'absolute',//or absolute
    colorx: 'red',
    colory: '#899FEC',
    duration: 100, //seconds
    period: 20, //ms
    smooth: 0.9,
    alpha: 0.03,
    beta: 0.03,
    a: 2.3,
    aa: 1,
    b: .6,
    c: -.15,
    d: .7,
    dd: 2,
    z11: 3,
    z12: 3,
    z21: -3,
    z22: -2,
    scale: 20,
    lvlset: 1,
    history: false,
    showInfo: false
  },
  I: { //inputs
    posX: 0,
    posY: 0,
  },
  O: { //outputs
    time: 0,
    costx: 0,
    costy: 0,
    gradx: 0,
    grady: 0
  },
  S: { //state
    time: 0,
    x: 0,
    y: 0,
  },
}

function reset(S, I, O, P) {
  S.x = -100
  S.y = 100
 }

function update(S, I, O, P) {
  var x1 = (S.x-P.z11*P.scale)
  var y1 = (S.y-P.z12*P.scale)
  var x2 = (S.x-P.z21*P.scale)
  var y2 = (S.y-P.z22*P.scale)

  O.costx = P.a*x1*x1/2 + P.b*x1*y1 + P.aa*y1*y1/2
  O.costy = P.d*y2*y2/2 + P.c*x2*y2 + P.dd*x2*x2/2
  O.costx /= P.scale
  O.costy /= P.scale

  O.gradx = P.a*x1 + P.b*y1
  O.grady = P.c*x2 + P.d*y2
  switch (P.mode) {
    case 'simgrad':
     S.x = S.x - P.alpha*O.gradx
     S.y = S.y - P.beta*O.grady
     break;
    case 'mouse': 
     S.x = I.posX
     S.y = S.y - P.beta*O.grady
     break;
    case 'both':
     S.x = I.posX
     S.y = I.posY
     break;
   }
}

function draw(canvas, S, I, O, P, H) {
  let ctx = canvas.getContext('2d')
  let w = canvas.width
  let h = canvas.height

  ctx.strokeStyle = 'white'
  ctx.fillStyle = 'white'
  ctx.lineWidth = 3

  ctx.strokeRect(-w/2, -h/2, w, h)




  ctx.strokeStyle = P.colorx
  r1 = (P.a+P.aa)/2 + Math.sqrt((P.a - P.aa)**2/4+P.b*P.b)
  r2 = (P.a+P.aa)/2 - Math.sqrt((P.a - P.aa)**2/4+P.b*P.b)
  t = Math.atan2(r1-P.a, P.b)
  for (var i=0; i<5; i++) {
  ctx.beginPath();
  ctx.ellipse(P.z11*P.scale, P.z12*P.scale, Math.sqrt(r2)*i*P.scale*P.lvlset, Math.sqrt(r1)*i*P.scale*P.lvlset, t, 0, 2*Math.PI)
  ctx.stroke()
   }
  ctx.beginPath();
  ctx.arc(P.z11*P.scale, P.z12*P.scale, 1, 0, 2*Math.PI)
  ctx.fill()


  ctx.strokeStyle = P.colory
  r1 = (P.d+P.dd)/2 + Math.sqrt((P.dd - P.d)**2/4+P.c*P.c)
  r2 = (P.d+P.dd)/2 - Math.sqrt((P.dd - P.d)**2/4+P.c*P.c)
  t = Math.atan2(r1-P.dd, P.c)
  for (var i=0; i<5; i++) {
  ctx.beginPath();
  ctx.ellipse(P.z21*P.scale, P.z22*P.scale, Math.sqrt(r2)*i*P.scale*P.lvlset, Math.sqrt(r1)*i*P.scale*P.lvlset, t, 0, 2*Math.PI)

  ctx.stroke()
   }
  ctx.beginPath();
  ctx.arc(P.z21*P.scale, P.z22*P.scale, 1, 0, 2*Math.PI)
  ctx.fill()

  ctx.lineWidth = 20;
  if (P.mode == 'both') {
    x = I.posX
    y = I.posY
   } else if (P.mode == 'mouse') {
     x = I.posX
     y = S.y
   } else if (P.mode == 'simgrad') {
     x = S.x
     y = S.y
    }

  ctx.lineWidth = 20
  ctx.strokeStyle = P.colorx
  ctx.beginPath();
   ctx.moveTo(x-5, -h/2)
   ctx.lineTo(x+5, -h/2)
  ctx.stroke()

  ctx.strokeStyle = P.colory
   ctx.beginPath();
   ctx.moveTo(w/2, y-5) 
   ctx.lineTo(w/2, y+5)
   ctx.stroke()

  ctx.beginPath();
  ctx.arc(S.x, S.y, 8, 0, 2*Math.PI)
  ctx.fill()

  ctx.lineWidth = 2
  if (P.history && H.S.x.length >= 1) {
  ctx.strokeStyle = "white"
   ctx.beginPath();
   ctx.moveTo(H.S.x[0], H.S.y[0]) 
    for (var i =0; i< H.S.x.length; i+= 2) {
ctx.lineTo(H.S.x[i], H.S.y[i])
     }
   ctx.stroke()
   }
 }

function inputs(canvas, S, I, O, P, x, y) {

  if (P.inputmode == 'lock') {
    I.movX = I.movX + x 
    I.movY = I.movY - y
  //}
  //if (P.inputmode == 'absolute') {
  //  I.posX = x - canvas.width/2
  //  I.posY = canvas.height -y
  //}
    I.posX = I.movX
    I.posY = I.movY
   } else {
    I.posX = x - canvas.width/2
    I.posY = canvas.height/2 -y
    }

  if (P.mode == 'lqr') I.posX = x

}

DynamSpace(update, draw, inputs, reset, data, experiments)

	</script>
</body>
</html>
